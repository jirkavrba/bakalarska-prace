\chapter{Zdrojové kódy výpočetních procedur}

\begin{lstlisting}[label={code:liquibase-changelog}, caption={SQL soubor s~migracemi pro nástroj Liquibase (vlastní zpracování)}]
--liquibase formatted sql

--changeset jirkavrba:create-accounts-table
create table accounts
(
    id int not null generated by default as identity primary key,
    username varchar(6) not null unique,
    verification_code varchar(8) null
);

--changeset jirkavrba:create-submission-reminders-table
create table submission_reminders
(
    id int not null generated by default as identity primary key,
    account_id int not null,
    submission_id int not null, -- internal ID used by InSIS
    submission_name varchar(128) not null,
    submission_course varchar(128) not null,
    submission_due timestamp with time zone not null,
    reminder_date timestamp with time zone not null
);

alter table submission_reminders
    add constraint fk_submission_reminders_account_id 
    foreign key (account_id) references accounts (id) 
    on delete cascade;

--changeset jirkavrba:create-timetable-events-table
create table timetable_events
(
    id int not null generated by default as identity primary key,
    account_id int not null,
    entry_datetime timestamp with time zone not null,
    entry_course varchar(128) not null,
    event_type varchar(128) not null,
    event_note varchar(1024) not null
);

--changeset jirkavrba:create-notifications-table
create table notifications
(
    id int not null generated by default as identity primary key,
    published_on timestamp with time zone not null,
    notification_text varchar(1024) not null,
    notification_link varchar(1024)
);
\end{lstlisting}

\begin{lstlisting}[label={code:timetable-event-domain-class}, caption={Zdrojový kód doménové třídy \code{TimetableEvent}}]
package dev.vrba.vseplus.api.domain

import org.springframework.data.annotation.Id
import org.springframework.data.relational.core.mapping.Column
import org.springframework.data.relational.core.mapping.Table
import java.time.LocalDateTime

@Table("timetable_events")
data class TimetableEvent(
    @Id
    val id: Int = 0,

    @Column("account_id")
    val account: Int,

    @Column("entry_datetime")
    val datetime: LocalDateTime,

    @Column("entry_course")
    val course: String,

    @Column("event_type")
    val type: String,

    @Column("event_note")
    val note: String
)
\end{lstlisting}

\begin{lstlisting}[label={code:timetable-events-repository}, caption={Definice repozitáře pro doménovou třídu \code{TimetableEvent}}]
package dev.vrba.vseplus.api.repository

import dev.vrba.vseplus.api.domain.TimetableEvent
import kotlinx.coroutines.flow.Flow
import org.springframework.data.repository.kotlin.CoroutineCrudRepository
import org.springframework.stereotype.Repository

@Repository
interface TimetableEventsRepository : CoroutineCrudRepository<TimetableEvent, Int> {

    suspend fun findAllByAccount(account: Int): Flow<TimetableEvent>

    suspend fun findByIdAndAccount(id: Int, account: Int): TimetableEvent?

}
\end{lstlisting}

\begin{lstlisting}[label={code:gitlab-ci-pipeline}, caption={Definice GitLab CI/CD pipeline pro sestavování balíčků rozšíření (vlastní zpracování)}]
stages:
  - prepare
  - build
  - release

prepare-release:
  stage: prepare
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  script:
    - echo "TAG=v$(cat VERSION)" >> variables.env
  artifacts:
    reports:
      dotenv: variables.env
  only:
    changes:
      - VERSION
    refs:
      - main

install-dependencies:
  stage: prepare
  image: node:alpine
  script:
    - npm install
  artifacts:
    expire_in: 1 hour
    paths:
      - node_modules
  cache:
    key:
      files:
        - package-lock.json
    paths:
      - node_modules
  only:
    changes:
      - VERSION
    refs:
      - main
    
build-chrome-extension:
  stage: build
  image: node:alpine
  script:
    - apk add zip
    - npm run chrome
    - npm run build
    - rm ./dist/manifest-chrome.json
    - rm ./dist/manifest-firefox.json
    - cd dist
    - zip ../extension-chrome.zip -r ./*
  needs:
    - install-dependencies
    - prepare-release
  artifacts:
    expire_in: 1 hour
    paths:
      - ./extension-chrome.zip
  only:
    changes:
      - VERSION
    refs:
      - main
    
build-firefox-extension:
  stage: build
  image: node:alpine
  script:
    - apk add zip
    - npm run firefox
    - npm run build
    - rm ./dist/manifest-chrome.json
    - rm ./dist/manifest-firefox.json
    - cd dist
    - zip ../extension-firefox.zip -r ./*
  needs:
    - install-dependencies
    - prepare-release
  artifacts:
    expire_in: 1 hour
    paths:
      - ./extension-firefox.zip
  only:
    changes:
      - VERSION
    refs:
      - main

release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  only:
    changes:
      - VERSION
    refs:
      - main
  script:
    - echo "Creating release for $TAG"
    - mkdir output
    - cp ./extension-chrome.zip ./output/extension-chrome-$TAG.zip
    - cp ./extension-firefox.zip ./output/extension-firefox-$TAG.zip
  artifacts:
    paths:
     - output
  release:
    name: "Release $TAG"
    description: "Automatically generated release for the version $TAG"
    tag_name: "$TAG"
    ref: "$CI_COMMIT_SHA"
    assets:
      links:
        - name: Chrome extension
          url: $CI_JOB_URL/artifacts/raw/output/extension-chrome-$TAG.zip
        - name: Firefox extension
          url: $CI_JOB_URL/artifacts/raw/output/extension-firefox-$TAG.zip
  needs:
    - build-firefox-extension
    - build-chrome-extension
    - prepare-release
\end{lstlisting}

\begin{lstlisting}[label={code:gitlab-ci-docker}, caption={GitLab CI/CD pipeline pro sestavování a publikaci docker image (vlastní zpracování)}]
stages:
  - test
  - prepare
  - build
  - release

prepare-release:
  stage: prepare
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  script:
    - echo "VERSION=$(cat gradle.properties | sed 's/^apiVersion=//')" >> variables.env
    - echo "TAG=v$(cat gradle.properties | sed 's/^apiVersion=//')" >> variables.env
  artifacts:
    reports:
      dotenv: variables.env

run-tests:
  stage: test
  image: docker:23.0.1-dind-alpine3.17 # Needs docker-in-docker for running test containers
  services:
    - docker:23.0.1-dind
  before_script:
    - apk add --update openjdk17
    - export GRADLE_USER_HOME=`pwd`/.gradle
  script:
    - chmod 755 ./gradlew
    - ./gradlew test
  cache:
    paths:
      - build
      - .gradle/wrapper
      - .gradle/caches
    key:
      files:
        - build.gradle.kts
        - settings.gradle.kts
  artifacts:
    reports:
      junit:
        - build/test-results/test/TEST-*.xml

build-docker-image:
  stage: build
  image: docker:23.0.1-dind-alpine3.17
  needs:
    - prepare-release
  services:
    - docker:23.0.1-dind
  before_script:
    - apk add --update openjdk17
    - export GRADLE_USER_HOME=`pwd`/.gradle
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - chmod 755 ./gradlew
    - ./gradlew bootBuildImage
    - docker push $CI_REGISTRY_IMAGE:$VERSION
  only:
    changes:
      - gradle.properties
    refs:
      - main
  cache:
    paths:
      - build
      - .gradle/wrapper
      - .gradle/caches
    key:
      files:
        - build.gradle.kts
        - settings.gradle.kts
    
release:
  stage: release
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - prepare-release
  only:
    changes:
      - gradle.properties
    refs:
      - main
  script:
    - echo "Creating release for $TAG"
  release:
    name: "Release $TAG"
    description: "Automatically generated release for the version $TAG"
    tag_name: "$TAG"
    ref: "$CI_COMMIT_SHA"
\end{lstlisting}

\begin{lstlisting}[label={code:accounts-controller}, caption={Definice třídy kontroleru pro uživatelské účty}]
package dev.vrba.vseplus.api.controller.api

import dev.vrba.vseplus.api.request.authentication.CreateAccountRequest
import dev.vrba.vseplus.api.request.authentication.VerifyAccountRequest
import dev.vrba.vseplus.api.response.authentication.CreateAccountResponse
import dev.vrba.vseplus.api.response.authentication.VerifyAccountResponse
import dev.vrba.vseplus.api.service.AccountService
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/account")
class AccountController(private val service: AccountService) {

    @PostMapping("/create")
    suspend fun createAccount(@Valid @RequestBody request: CreateAccountRequest): ResponseEntity<CreateAccountResponse> {
        val account = service.createAccount(request.username)
        val response = CreateAccountResponse(
            username = account.username,
            message = "Na email ${account.email} byl zaslán ověřovací kód"
        )

        return ResponseEntity.ok(response)
    }

    @PostMapping("/verify")
    suspend fun verifyAccount(@Valid @RequestBody request: VerifyAccountRequest): ResponseEntity<VerifyAccountResponse> {
        val token = service.verifyAccount(request.username, request.code) ?: return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY).build()
        val response = VerifyAccountResponse(
            username = request.username,
            token = token
        )

        return ResponseEntity.ok(response)
    }
}
\end{lstlisting}

\begin{lstlisting}[label={code:create-account-request}, caption={Definice třídy \code{CreateAccountRequest} sloužící pro přenos dat}]
package dev.vrba.vseplus.api.request.authentication

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

class CreateAccountRequest(
    @field:NotBlank
    @field:Size(min = 6, max = 6)
    @field:Pattern(regexp = "^[a-z]+[a-z0-9]+$")
    val username: String
)
\end{lstlisting}

\begin{lstlisting}[label={code:create-account-response}, caption={Definice třídy \code{CreateAccountResponse} sloužící pro přenos dat}]
package dev.vrba.vseplus.api.response.authentication

data class CreateAccountResponse(
    val username: String,
    val message: String
)
\end{lstlisting}
